//
// Created by Shrekulka on 31.05.2023.
//

#include "Matrix.h"


// Конструктор с параметрами
// rows - количество строк матрицы (по-умолчанию 1)
// cols - количество столбцов матрицы (по-умолчанию 1)
// fill - значение, которым изначально будет заполнена матрица (по-умолчанию 0)
Matrix::Matrix(unsigned rows, unsigned cols, double fill) :
// устанавливаем размеры матрицы
		_rows(rows), _cols(cols)
{
	// Выделяем память под массив строк
	_matrix = new Row[_rows];

	// Устанавливаем необходимы размер для каждой строки
	// и заполняем матрицу желаемым значением
	for (unsigned i = 0; i < _rows; ++i)
		_matrix[i].resize(_cols, fill);
}

// Конструктор копирования
Matrix::Matrix(const Matrix& original) :
// Устанавливаем размеры матрицы
		_rows(original._rows), _cols(original._cols)
{
	// Выделяем память под массив строк
	_matrix = new Row[_rows];

	// Каждую строку новой матрицы
	// инициализируем соответствующей
	// строкой матрицы original
	for (unsigned i = 0; i < _rows; ++i)
		_matrix[i] = original._matrix[i];
}

// Деструктор
Matrix::~Matrix()
{
	// Удаляем память, отведуннёю под массив строк
	delete[] _matrix;
}

// Функция изменения резмера матрицы
void Matrix::resize(unsigned rows, unsigned cols, double fill)
{
	// Если исходные размеры матрицы
	// не совпадают с желаемыми
	if (_rows != rows || _cols != cols)
	{
		// Освобождаем память из-под исходной матрицы
		delete[] _matrix;

		// Устанавливаем размеры матрицы
		// равными желаемому
		_rows = rows;
		_cols = cols;

		// Выделяем память под матрицу нового размера
		_matrix = new Row[_rows];
	}

	// Устанавливаем необходимы размер для каждой строки
	// и заполняем матрицу желаемым значением
	for (unsigned i = 0; i < _rows; ++i)
		_matrix[i].resize(_cols, fill);
}

// Функция, вычисляющая определитель матрицы
// Используется метод Гаусса-Жордана. Суть метода состоит в
// том, что если из данной матрицы получить с помощью элементарных
// преобразований верхнюю треугольную, то определитель исходной
// матрицы будет равен произведению элементов на главной диагонали
// полученной матрицы.
// Используются следующие свойства определителя:
// 1. Определитель не изменится, если к элементам одного ряда
//    прибавить элементы другого ряда, умноженные на произвольное
//    число
// 2. При перестановке двух параллельных рядов определитель
//    меняет знак
double Matrix::det() const
{
	Matrix copy(*this);        // Копия исходной матрицы
	double result = 1.0;       // Результат
	unsigned dim = copy._rows; // Размерность матрицы
	int sign = 1;              // Знак определителя
	bool key = true;           // Вспомогательная переменная - индикатор,
	// была ли найдена строка с ненулевым элементом
	// в k-ом столбце

	// Дальнейшие действия выполняются, только если
	// исходная матрица - квадратная
	if (copy._rows == copy._cols)
	{
		// Проходим по строкам матрицы (назовём их исходными)
		for (unsigned k = 0; k < dim; ++k)
		{
			// Если элемент на главной диагонали в исходной
			// строке - нуль, то ищем строку, где элемент
			// того же столбца не нулевой, и меняем строки
			// местами, а так же (исходя из свойства 2
			// определителя), меняем знак результата на
			// противоположный, или, если такую строку
			// найти не удалось - определитель равен нулю
			// и функция завершает работу
			if (copy._matrix[k][k] == 0.0)
			{
				// Изначально устанавливаем индикатор
				// в положение "Не найдено"
				key = false;

				// Идём по строкам, расположенным ниже исходной
				for (unsigned i = k + 1; i < dim; ++i)
				{
					// Если нашли строку, где в том же столбце
					// имеется не нулевой элемент
					if (copy._matrix[i][k] != 0.0)
					{
						// Устанавливаем индикатор в положение "Найдено"
						key = true;

						// Меняем найденную и исходную строки местами
						std::swap(copy._matrix[k], copy._matrix[i]);

						// Меняем знак результата
						sign *= -1;

						break;
					}
				}
			}

			// Если на каком-то этапе не нашли столбца с ненулевыми элементами
			// ниже k-ой позиции - определитель равен нулю
			if (!key)
			{
				return 0.0;
			}

			// Идём по строкам, которые расположены ниже исходной
			for (unsigned i = k + 1; i < dim; ++i)
			{
				// Запоминаем множитель - отношение элемента очередной
				// строки, расположенного под диагональным элементом
				// исходной строки, к диагональному элементу исходной
				// строки (для того, чтобы постепенно формировать
				// верхнетреугольную матрицу, ведь на каждом шаге
				// внешнего цикла по k внутри данного цикла будет
				// зануляться столбец элементов, расположенных
				// ниже диагонального)
				double multi = copy._matrix[i][k] / copy._matrix[k][k];

				// Отнимаем от очередной строки исходную, умноженную
				// на сохранённый ранее множитель
				for (unsigned j = 0; j < dim; ++j)
					copy._matrix[i][j] -= multi * copy._matrix[k][j];
			}

			// Добавляем к результату очередное вычисленное значение
			// на главной диагонали, поскольку оно больше не изменится
			result *= copy._matrix[k][k];
		}
	}
	else
	{
		return 0.0;
	}

	// Окончательно формируем результат с учётом получившегося знака
	return sign * result;
}

// Функция, вычисляющая обратную матрицу
// Используется метод Гаусса-Жордана. Суть метода состоит в
// том, что если из данной матрицы получить с помощью
// элементарных преобразований единичную, а затем все те же
// преобразования применить к единичной матрице, то полученная
// на месте единичной матрица будет обратной матрицей для
// исходной.
Matrix Matrix::inverse() const
{
	Matrix E(_rows, _rows); // Единичная матрица
	Matrix copy(*this);     // Копия исходной матрицы
	unsigned dim = _rows;   // Размернойсть матрицы

	// Все дальнейшие действия выполняются,
	// только если определитель исходной
	// матрицы не равен нулю
	if (det() != 0.0)
	{
		// Формируем единичную матрицу из нулевой
		// добавлением единиц на главную диагональ
		for (unsigned i = 0; i < dim; ++i)
			E._matrix[i][i] = 1.0;

		// Проходим по строкам матрицы (назовём их исходными)
		// сверху вниз. На данном этапе происходит прямой ход
		// и исходная матрица превращается в верхнюю треугольную
		for (unsigned k = 0; k < dim; ++k)
		{
			// Если элемент на главной диагонали в исходной
			// строке - нуль, то ищем строку, где элемент
			// того же столбца не нулевой, и меняем строки
			// местами
			if (copy._matrix[k][k] == 0.0)
			{
				// Идём по строкам, расположенным ниже исходной
				for (unsigned i = k + 1; i < dim; ++i)
				{
					// Если нашли строку, где в том же столбце
					// имеется не нулевой элемент
					if (copy._matrix[i][k] != 0.0)
					{
						// Меняем найденную и исходную строки местами
						// как в исходной матрице, так и в единичной
						std::swap(copy._matrix[k], copy._matrix[i]);
						std::swap(E._matrix[k], E._matrix[i]);

						break;
					}
				}
			}

			// Запоминаем делитель - диагональный элемент
			double div = copy._matrix[k][k];

			// Все элементы исходной строки делим на диагональный
			// элемент как в исходной матрице, так и в единичной
			for (unsigned j = 0; j < dim; ++j)
			{
				copy._matrix[k][j] /= div;
				E._matrix[k][j] /= div;
			}

			// Идём по строкам, которые расположены ниже исходной
			for (unsigned i = k + 1; i < dim; ++i)
			{
				// Запоминаем множитель - элемент очередной строки,
				// расположенный под диагональным элементом исходной
				// строки
				double multi = copy._matrix[i][k];

				// Отнимаем от очередной строки исходную, умноженную
				// на сохранённый ранее множитель как в исходной,
				// так и в единичной матрице
				for (unsigned j = 0; j < dim; ++j)
				{
					copy._matrix[i][j] -= multi * copy._matrix[k][j];
					E._matrix[i][j] -= multi * E._matrix[k][j];
				}
			}
		}

		// Проходим по вернхней треугольной матрице, полученной
		// на прямом ходе, снизу вверх
		// На данном этапе происходит обратный ход, и из исходной
		// матрицы окончательно формируется единичная, а из единичной -
		// обратная
		for (unsigned k = dim - 1; k > 0; --k)
		{
			// Идём по строкам, которые расположены выше исходной
			for (unsigned i = k - 1; i + 1 > 0; --i)
			{
				// Запоминаем множитель - элемент очередной строки,
				// расположенный над диагональным элементом исходной
				// строки
				double multi = copy._matrix[i][k];

				// Отнимаем от очередной строки исходную, умноженную
				// на сохранённый ранее множитель как в исходной,
				// так и в единичной матрице
				for (unsigned j = 0; j < dim; ++j)
				{
					copy._matrix[i][j] -= multi * copy._matrix[k][j];
					E._matrix[i][j] -= multi * E._matrix[k][j];
				}
			}
		}
	}
		// Иначе, если определитель исходной матрицы
		// равен нулю, изменяем матрицу E так, чтобы
		// она имела одну строку и один столбец, т.е.
		// единственный элемент со значением 0
	else
	{
		E.resize();
	}

	// Возвращаем полученную на месте единичной
	// обратную матрицу или нуль в случае, если
	// обратной для данной матрицы не существует
	return E;
}

// Функция, вычисляющая ранг матрицы
// Используется метод элементарных преобразований.
// Суть метода состоит в том, что если из данной матрицы
// получить с помощью элементарных преобразований трапециевидную,
// а затем в полученной матрице посчитать количество нулевых строк
// и отнять его от общего количества строк, то в результате получим
// ранг матрицы
int Matrix::rang() const
{
	Matrix copy(*this); // Копия исходной матрицы
	int count = 0;      // Количество нулевых строк
	bool key = true;    // Вспомогательная переменная - индикатор,
	// была ли найдена строка с ненулевым элементом
	// в k-ом столбце. Также служит для определения
	// того, является ли строка матрице нулевой
	// (на заключительном этапе)

	// Проходим по строкам матрицы (назовём их исходными)
	// сверху вниз и приводим матрицу к трапециевидной
	for (unsigned k = 0; k < _rows; ++k)
	{
		// Если элемент на главной диагонали в исходной
		// строке - нуль, то ищем строку, где элемент
		// того же столбца не нулевой, и меняем строки
		// местами, или, если такую строку найти не удалось,
		// прерываем цикл
		if (copy._matrix[k][k] == 0.0)
		{
			// Изначально устанавливаем индикатор
			// в положение "Не найдено"
			key = false;

			// Идём по строкам, расположенным ниже исходной
			for (unsigned i = k + 1; i < _rows; ++i)
			{
				// Если нашли строку, где в том же столбце
				// имеется не нулевой элемент
				if (copy._matrix[i][k] != 0.0)
				{
					// Устанавливаем индикатор в положение "Найдено"
					key = true;

					// Меняем найденную и исходную строки местами
					std::swap(copy._matrix[k], copy._matrix[i]);

					break;
				}
			}
		}

		// Если на каком-то этапе не нашли столбца с ненулевыми элементами
		// ниже k-ой позиции - прерываем цикл
		if (!key)
		{
			break;
		}

		// Идём по строкам, которые расположены ниже исходной
		for (unsigned i = k + 1; i < _rows; ++i)
		{
			// Запоминаем множитель - элемент очередной строки,
			// расположенный под диагональным элементом исходной
			// строки, делённый на диагональный элемент исходной
			// строки
			double multi = copy._matrix[i][k] / copy._matrix[k][k];

			// Отнимаем от очередной строки исходную, умноженную
			// на сохранённый ранее множитель
			for (unsigned j = 0; j < _cols; ++j)
				copy._matrix[i][j] -= multi * copy._matrix[k][j];
		}
	}

	// Считаем количество нулевых строк
	for (unsigned i = 0; i < _rows; ++i)
	{
		// Изначально ключ нулевой строки
		// устанавливаем в положение "Нулевая"
		key = false;

		// Если при проходе по строке встретился
		// ненулевой элемент, устанавливаем ключ
		// в положение "Не нулевая"
		for (unsigned j = 0; j < _cols; ++j)
			if (copy._matrix[i][j] != 0.0)
			{
				key = true;
			}

		// Если после прохода по строке ключ остался
		// в положении "Нулевая", увеличиваем счётчик
		// нулевых строк
		if (!key)
		{
			count++;
		}
	}

	// Возвращаем ранг матрицы - результат вычитания
	// из общего количества строк количества нулевых
	// строк, полученных после элементарных преобразований
	// исходной матрицы
	return _rows - count;
}

// Функция транспонирования матрицы
Matrix Matrix::transpose() const
{
	Matrix result(this->_cols, this->_rows); // Результирующая матрица, размеры которой
	// противоположны размерам исходной матрицы

	// В цикле идём по всем элементам исходной матрицы
	// и записываем их на места соответствующих элементов
	// результирующей матрицы (в результирующей матрице в
	// итоге будут элементы исходной матрицы, отражённые
	// относительно главной диагонали)
	for (unsigned i = 0; i < _cols; ++i)
		for (unsigned j = 0; j < _rows; ++j)
			result._matrix[i][j] = _matrix[j][i];

	// Возвращаем результат транспонирования
	return result;
}

// Перегруженный оператор взятия строки по индексу
Row& Matrix::operator[](unsigned index)
{
	// Возвращаем ссылку на желаемую строку
	return _matrix[index];
}

// Перегруженный оператор взятия строки по индексу (константный)
const Row& Matrix::operator[](unsigned index) const
{
	// Возвращаем константную ссылку на желаемую строку
	return _matrix[index];
}

// Перегруженный оператор вывода из потока input
std::istream& operator>>(std::istream& input, Matrix& rhs)
{
	// Идём по строкам матрицы
	for (unsigned i = 0; i < rhs._rows; ++i)
		// Вводим очередную строку матрицы
		input >> rhs._matrix[i];

	// Возвращаем ссылку на поток input
	return input;
}

// Перегруженный оператор ввода в поток output
std::ostream& operator<<(std::ostream& output, const Matrix& rhs)
{
	// Идём по строкам матрицы
	for (unsigned i = 0; i < rhs._rows; ++i)
		// Выводим очередную строку матрицы
		output << rhs._matrix[i] << std::endl;

	// Возвращаем ссылку на поток output
	return output;
}

// Перегруженный оператор сложения матриц, результат отдельно
Matrix Matrix::operator+(const Matrix& rhs) const
{
	Matrix result(*this); // Результирующая матрица, равна
	// изначально первой матрице

	// Если количество строк и столбцов первой матрицы
	// совпадает с количеством соответственно строк и
	// столбцов второй матрицы
	if (_rows == rhs._rows && _cols == rhs._cols)
	{
		// Идём по строкам матрицы
		for (unsigned i = 0; i < _rows; ++i)
			// Идём по элементам очередной строки
			for (unsigned j = 0; j < _cols; ++j)
				// Прибавляем к каждому элементу результируещей
				// матрицы (который изначально совпадает с
				// соответствующим элементом первой матрицы)
				// соответствующий элемент второй матрицы
				result._matrix[i][j] += rhs._matrix[i][j];
	}
		// Если размеры левой и правой матриц не совпадают,
		// результатом операции сложения будет число 0
	else
	{
		result.resize();
	}

	// Возвращаем результирующую матрицу
	return result;
}

// Перегруженный оператор сложения матриц, результат в правой матрице
const Matrix& Matrix::operator+=(const Matrix& rhs)
{
	// Сохраняем в правую матрицу результат
	// сложения правой и левой матриц посредством
	// перегруженной операции сложения матриц
	*this = *this + rhs;

	return *this;
}

// Перегруженный оператор вычитания матриц, результат отдельно
Matrix Matrix::operator-(const Matrix& rhs) const
{
	// Используется уже реализованный оператор
	// умножения матрицы на число и оператор
	// сложения матриц
	return *this + (-1.0) * rhs;
}

// Перегруженный оператор вычитания матриц, результат в левой матрице
const Matrix& Matrix::operator-=(const Matrix& rhs)
{
	// Используется уже реализованный оператор
	// вычитания матриц
	*this = *this - rhs;

	return *this;
}

// Перегруженный оператор умножения двух матриц, результат отдельно
Matrix Matrix::operator*(const Matrix& rhs) const
{
	Matrix result(_rows, rhs._cols); // Результирующая матрица будет иметь столько же
	// строк, сколько и левая матрица, и столько же
	// столбцов, сколько правая

	// Умножение матриц возможно, только если
	// количество столбцов левой матрицы и
	// количество строк правой совпадают
	if (_cols == rhs._rows)
	{
		// Идём по строкам левой матрицы
		for (unsigned i = 0; i < _rows; ++i)
			// Идём по столбцам правой матрицы
			for (unsigned j = 0; j < rhs._cols; ++j)
				// Идём по столбцам левой (и по строка правой) матрицы
				for (unsigned k = 0; k < _cols; ++k)
					// Формируем очередной элемент результирующей матрицы
					result._matrix[i][j] += _matrix[i][k] * rhs._matrix[k][j];
	}
		// Если количество столбцов левой и количество
		// строк правой матрицы не совпадают, то
		// результатом выполнения операции будет
		// число 0
	else
	{
		result.resize();
	}

	// Возвращаем результат умножения
	return result;
}

// Перегруженный оператор умножения двух матриц, результат в левой матрице
const Matrix& Matrix::operator*=(const Matrix& rhs)
{
	// Используется уже реализованный оператор
	// умножения матриц
	*this = *this * rhs;

	return *this;
}

// Перегруженный оператор умножения матрицы на число
// (матрица слева, число справа), результат отдельно
Matrix operator*(const Matrix& lhs, const double rhs)
{
	Matrix result(lhs); // Изначально результирующая матрица
	// совпадает с исходной

	// Каждый элемент исходной матрицы умножаем на требуемое число
	for (unsigned i = 0; i < lhs._rows; ++i)
		for (unsigned j = 0; j < lhs._cols; ++j)
			result._matrix[i][j] *= rhs;

	// Возвращаем результирующую матрицу
	return result;
}

// Перегруженный оператор умножения матрицы на число
// (матрица слева, число справа), результат в матрице
const Matrix& operator*=(Matrix& lhs, const double rhs)
{
	// Используется уже реализованный оператор
	// умножения матрицы на число
	lhs = lhs * rhs;

	return lhs;
}

// Перегруженный оператор умножения матрицы на число
// (матрица справа, число слева), результат отдельно
Matrix operator*(const double lhs, const Matrix& rhs)
{
	// Используется уже реализованный оператор
	// умножения матрицы на число
	return rhs * lhs;
}

// Перегруженный оператор деления матриц (т.е. умножения левой
// матрицы на обратную для правой матрицу), результат отдельно
Matrix Matrix::operator/(const Matrix& rhs) const
{
	// Используется уже реализованный оператор умножения
	// матриц, а так же функция, находящая обратную матрицу
	return *this * rhs.inverse();
}

// Перегруженный оператор деления матриц (т.е. умножения левой
// матрицы на обратную для правой матрицу), результат в левой матрице
const Matrix& Matrix::operator/=(const Matrix& rhs)
{
	// Используется уже реализованный оператор деления матриц
	*this = *this / rhs;

	return *this;
}

// Перегруженный оператор деления матрицы на число (т.е.
// умножение матрицы на обратное число), результат отдельно
Matrix operator/(const Matrix& lhs, const double rhs)
{
	// Используется уже реализованный оператор умножения
	// матрицы на число
	return lhs * (1.0 / rhs);
}

// Перегруженный оператор деления матрицы на число (т.е. умножения
// матрицы на обратное число), результат в матрице
const Matrix& operator/=(Matrix& lhs, const double rhs)
{
	// Используется уже реализованный оператор деления
	// матрицы на число
	lhs = lhs / rhs;

	return lhs;
}

// Перегруженный оператор деления числа на матрицу (т.е. умножения
// числа на обратную матрицу), результат отдельно
Matrix operator/(const double lhs, const Matrix& rhs)
{
	// Используется уже реализованный оператор умножения
	// матрицы на число, а так же функция, находящая
	// обратную матрицу
	return lhs * rhs.inverse();
}

// Перегруженная операция возведения матрицы в целую степень
// (положительную или отрицательную), результат отдельно
Matrix Matrix::operator^(const int power) const
{
	Matrix result(*this);                         // Изначально в результирующую матрицу копируем исходную
	unsigned _power = power > 0 ? power : -power; // Сохраняем абсолютное значение показателя степени

	// Продолжаем, только если матрица квадратная
	if (_rows == _cols)
	{
		// Если показатель степени равен нулю, то результирующей матрицей
		// будет являться единичная матрица той же размерности, что и исходная
		if (_power == 0)
		{
			// Заполняем результирующую матрицу нулями
			result.resize(_rows, _cols, 0.0);

			// Устанавливаем единицы на главной диагонали
			for (unsigned i = 0; i < _rows; ++i)
				result._matrix[i][i] = 1.0;
		}
			// Если показатель степени ненулевой
		else
		{
			// Возводим матрицу в нужную степень
			for (unsigned i = 1; i < _power; ++i)
				result *= *this;

			// Если исходный показатель был отрицательным,
			// обращаем полученную матрицу
			if (power < 0)
			{
				result = result.inverse();
			}
		}
	}
		// Если матрица неквадратная, результатом выполнения
		// операции будет число 0
	else
	{
		result.resize();
	}

	// Возвращаем результат возведения матрицы в степень
	return result;
}

// Перегруженная операция возведения матрицы в целую степень
// (положительную или отрицательную), результат в матрице
const Matrix& Matrix::operator^=(const int power)
{
	// Используется уже реализованный оператор возведения
	// матрицы в целую степень
	*this = *this ^ power;

	return *this;
}

// Перегруженный оператор сравнения матриц
bool Matrix::operator==(const Matrix& rhs) const
{
	// Если размеры матриц не совпадают, то матрицы заведомо не равны
	if (_rows != rhs._rows || _cols != rhs._cols)
	{
		return false;
	}

	// Если на какие-либо строки матриц различаются,
	// то матрицы не равны
	for (unsigned i = 0; i < _rows; ++i)
		if (_matrix[i] != rhs._matrix[i])
		{
			return false;
		}

	// Если как размеры, так и все элементы матриц совпадают,
	// то матрицы равны
	return true;
}

// Перегруженный оператор неравенства матриц
bool Matrix::operator!=(const Matrix& rhs) const
{
	// Используется уже реализованный оператор сравнения матриц
	return !(*this == rhs);
}

// Перегруженный оператор присваивания одной матрицы другой
const Matrix& Matrix::operator=(const Matrix& rhs)
{
	// Проверка на самоприсваивание
	if (this != &rhs)
	{
		// Если размеры матриц не совпадают
		if (_rows != rhs._rows || _cols != rhs._cols)
		{
			// Очищаем память из-под старой матрицы
			delete[] _matrix;

			// Устанавливаем новые размеры
			_rows = rhs._rows;
			_cols = rhs._cols;

			// Выделяем память под новую матрицу
			_matrix = new Row[_rows];

			// Устанавливаем необходимы размер для каждой строки
			for (unsigned i = 0; i < _rows; ++i)
				_matrix[i].resize(_cols);
		}

		// Заполняем новую матрицу элементами из
		// присваиваемой
		for (unsigned i = 0; i < _rows; ++i)
			_matrix[i] = rhs._matrix[i];
	}

	return *this;
}

// Шаблонная функция обмена двух элементов местами
template<typename T>
void swap(T& a, T& b)
{
	// Стандартный обмен переменных местами
	T temp = a;
	a = b;
	b = temp;
}

